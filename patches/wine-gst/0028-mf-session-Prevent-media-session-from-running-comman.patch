From fd142f60edcc93c8a1a176cc5eb3d55a8f90087a Mon Sep 17 00:00:00 2001
From: Bones <babblebones@protnmail.com>
Date: Tue, 12 Aug 2025 14:06:57 -0400
Subject: [PATCH] mf/session: Prevent media session from running commands
 concurrently.

---
 dlls/mf/session.c | 141 ++++++++++++++++++++++++++++++----------------
 1 file changed, 92 insertions(+), 49 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 704e6bad981..c981b07a8d4 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -224,7 +224,7 @@ enum presentation_flags
     SESSION_FLAG_END_OF_PRESENTATION = 0x10,
     SESSION_FLAG_PENDING_RATE_CHANGE = 0x20,
     SESSION_FLAG_PENDING_COMMAND = 0x40,
-    SESSION_FLAG_RESTARTING = 0x80,
+    SESSION_FLAG_QUEUED_COMMAND = 0x80,
 };
 
 struct media_session
@@ -467,25 +467,48 @@ static HRESULT session_is_shut_down(struct media_session *session)
     return session->state == SESSION_STATE_SHUT_DOWN ? MF_E_SHUTDOWN : S_OK;
 }
 
+static void session_schedule_command(struct media_session *session)
+{
+    struct session_op *op;
+    struct list *e;
+
+    if (session->presentation.flags & (SESSION_FLAG_PENDING_COMMAND | SESSION_FLAG_QUEUED_COMMAND))
+    {
+        TRACE("not queueing: flags %x\n", session->presentation.flags);
+        return;
+    }
+
+    if (session->state != SESSION_STATE_STOPPED && session->state != SESSION_STATE_STARTED &&
+        session->state != SESSION_STATE_PAUSED && session->state != SESSION_STATE_CLOSED &&
+        session->state != SESSION_STATE_SHUT_DOWN)
+    {
+        TRACE("not queueing: state %x\n", session->state);
+        return;
+    }
+
+    if ((e = list_head(&session->commands)))
+    {
+        op = LIST_ENTRY(e, struct session_op, entry);
+        MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
+        session->presentation.flags |= SESSION_FLAG_QUEUED_COMMAND;
+    }
+}
+
 static HRESULT session_submit_command(struct media_session *session, struct session_op *op)
 {
     HRESULT hr;
 
-    TRACE("session %p, op %p, command %u.\n", session, op, op->command);
+    list_init(&op->entry);
 
     EnterCriticalSection(&session->cs);
     if (SUCCEEDED(hr = session_is_shut_down(session)))
     {
-        if (list_empty(&session->commands) && !(session->presentation.flags & SESSION_FLAG_PENDING_COMMAND))
-        {
-            hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
-            op->submitted = SUCCEEDED(hr);
-        }
         if (op->command == SESSION_CMD_SHUTDOWN)
             list_add_head(&session->commands, &op->entry);
         else
             list_add_tail(&session->commands, &op->entry);
         IUnknown_AddRef(&op->IUnknown_iface);
+        session_schedule_command(session);
     }
     LeaveCriticalSection(&session->cs);
 
@@ -971,19 +994,9 @@ static struct topo_node *session_get_topo_node_output(const struct media_session
 
 static void session_command_complete(struct media_session *session)
 {
-    struct session_op *op;
-    struct list *e;
-    HRESULT hr;
-
-    session->presentation.flags &= ~SESSION_FLAG_PENDING_COMMAND;
-
+    session->presentation.flags &= ~(SESSION_FLAG_PENDING_COMMAND | SESSION_FLAG_QUEUED_COMMAND);
     /* Submit next command. */
-    if ((e = list_head(&session->commands)))
-    {
-        op = LIST_ENTRY(e, struct session_op, entry);
-        hr = MFPutWorkItem(MFASYNC_CALLBACK_QUEUE_STANDARD, &session->commands_callback, &op->IUnknown_iface);
-        op->submitted = SUCCEEDED(hr);
-    }
+    session_schedule_command(session);
 }
 
 static void session_command_complete_with_event(struct media_session *session, MediaEventType event,
@@ -1136,26 +1149,17 @@ static void session_reset_transforms(struct media_session *session, BOOL drop)
     }
 }
 
-static void session_set_source_output_nodes_seeking(struct media_session *session)
+static void session_set_state(struct media_session *session, enum session_state new_state)
 {
-    struct media_source *source;
-    struct topo_node *node;
-
-    LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
-    {
-        source->state = OBJ_STATE_SEEKING;
-    }
-
-    LIST_FOR_EACH_ENTRY(node, &session->presentation.nodes, struct topo_node, entry)
-    {
-        if (node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || node->type == MF_TOPOLOGY_OUTPUT_NODE)
-            node->state = OBJ_STATE_SEEKING;
-    }
+    TRACE("setting state to %d\n", new_state);
+    session->state = new_state;
+    session_schedule_command(session);
 }
 
 static void session_start(struct media_session *session, const GUID *time_format, const PROPVARIANT *start_position)
 {
     struct media_source *source;
+    struct topo_node *node;
     MFTIME duration;
     HRESULT hr;
 
@@ -1189,7 +1193,20 @@ static void session_start(struct media_session *session, const GUID *time_format
                         else if (node->type == MF_TOPOLOGY_TRANSFORM_NODE)
                             IMFTransform_ProcessMessage(node->object.transform, MFT_MESSAGE_COMMAND_FLUSH, 0);
                     }
-                    session_set_source_output_nodes_seeking(session);
+                }
+
+                if (start_position->vt != VT_EMPTY)
+                {
+                    LIST_FOR_EACH_ENTRY(source, &session->presentation.sources, struct media_source, entry)
+                    {
+                        source->state = OBJ_STATE_SEEKING;
+                    }
+
+                    LIST_FOR_EACH_ENTRY(node, &session->presentation.nodes, struct topo_node, entry)
+                    {
+                        if (node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || node->type == MF_TOPOLOGY_OUTPUT_NODE)
+                            node->state = OBJ_STATE_SEEKING;
+                    }
                 }
 
                 /* Stop sources */
@@ -1208,11 +1225,13 @@ static void session_start(struct media_session *session, const GUID *time_format
                 PropVariantCopy(&session->presentation.start_position, start_position);
 
                 /* SESSION_STATE_STARTED -> SESSION_STATE_RESTARTING_SOURCES -> SESSION_STATE_STARTED */
-                session->state = SESSION_STATE_RESTARTING_SOURCES;
+                session_set_state(session, SESSION_STATE_RESTARTING_SOURCES);
                 break;
             }
             /* fallthrough; we're resuming from the current position */
         case SESSION_STATE_STOPPED:
+        {
+            enum session_state new_state = SESSION_STATE_STARTED;
             /* Start request with no current topology. */
             if (session->presentation.topo_status == MF_TOPOSTATUS_INVALID)
             {
@@ -1239,10 +1258,34 @@ static void session_start(struct media_session *session, const GUID *time_format
                     session_handle_start_error(session, hr);
                     return;
                 }
+
+                if (start_position->vt != VT_EMPTY)
+                    source->state = OBJ_STATE_SEEKING;
+
+                if (source->state != OBJ_STATE_STARTED)
+                    new_state = SESSION_STATE_STARTING_SOURCES;
+            }
+
+            LIST_FOR_EACH_ENTRY(node, &session->presentation.nodes, struct topo_node, entry)
+            {
+                if (node->type == MF_TOPOLOGY_OUTPUT_NODE)
+                {
+                    struct media_stream *stream = node->object.stream_sink;
+                    if (stream)
+                    {
+                        stream->draining = FALSE;
+                    }
+                }
+                else if (start_position->vt != VT_EMPTY)
+                {
+                    if (node->type == MF_TOPOLOGY_SOURCESTREAM_NODE || node->type == MF_TOPOLOGY_OUTPUT_NODE)
+                        node->state = OBJ_STATE_SEEKING;
+                }
             }
 
-            session->state = SESSION_STATE_STARTING_SOURCES;
+            session_set_state(session, new_state);
             break;
+        }
 
         default:
             session_command_complete_with_event(session, MESessionStarted, MF_E_INVALIDREQUEST, NULL);
@@ -1257,7 +1300,7 @@ static void session_set_started(struct media_session *session)
     unsigned int caps;
     DWORD flags;
 
-    session->state = SESSION_STATE_STARTED;
+    session_set_state(session, SESSION_STATE_STARTED);
 
     caps = session->caps | MFSESSIONCAP_PAUSE;
 
@@ -1289,7 +1332,7 @@ static void session_set_paused(struct media_session *session, unsigned int state
     /* Failed event status could indicate a failure during normal transition to paused state,
        or an attempt to pause from invalid initial state. To finalize failed transition in the former case,
        state is still forced to PAUSED, otherwise previous state is retained. */
-    if (state != ~0u) session->state = state;
+    if (state != ~0u) session_set_state(session, state);
     if (SUCCEEDED(status))
         session_set_caps(session, session->caps & ~MFSESSIONCAP_PAUSE);
     session_command_complete_with_event(session, MESessionPaused, status, NULL);
@@ -1297,7 +1340,7 @@ static void session_set_paused(struct media_session *session, unsigned int state
 
 static void session_set_closed(struct media_session *session, HRESULT status)
 {
-    session->state = SESSION_STATE_CLOSED;
+    session_set_state(session, SESSION_STATE_CLOSED);
     if (SUCCEEDED(status))
         session_set_caps(session, session->caps & ~(MFSESSIONCAP_START | MFSESSIONCAP_SEEK));
     session_command_complete_with_event(session, MESessionClosed, status, NULL);
@@ -1314,7 +1357,7 @@ static void session_pause(struct media_session *session)
 
             /* Transition in two steps - pause the clock, wait for sinks, then pause sources. */
             if (SUCCEEDED(hr = IMFPresentationClock_Pause(session->clock)))
-                session->state = SESSION_STATE_PAUSING_SINKS;
+                session_set_state(session, SESSION_STATE_PAUSING_SINKS);
             state = SESSION_STATE_PAUSED;
 
             break;
@@ -1352,7 +1395,7 @@ static void session_set_stopped(struct media_session *session, HRESULT status)
     MediaEventType event_type;
     IMFMediaEvent *event;
 
-    session->state = SESSION_STATE_STOPPED;
+    session_set_state(session, SESSION_STATE_STOPPED);
     event_type = session->presentation.flags & SESSION_FLAG_END_OF_PRESENTATION ? MESessionEnded : MESessionStopped;
 
     if (SUCCEEDED(MFCreateMediaEvent(event_type, &GUID_NULL, status, NULL, &event)))
@@ -1377,7 +1420,7 @@ static void session_stop(struct media_session *session)
             /* Transition in two steps - stop the clock, wait for sinks, then stop sources. */
             IMFPresentationClock_GetTime(session->clock, &session->presentation.clock_stop_time);
             if (SUCCEEDED(hr = IMFPresentationClock_Stop(session->clock)))
-                session->state = SESSION_STATE_STOPPING_SINKS;
+                session_set_state(session, SESSION_STATE_STOPPING_SINKS);
             else
                 session_set_stopped(session, hr);
 
@@ -1399,7 +1442,7 @@ static HRESULT session_finalize_sinks(struct media_session *session)
     HRESULT hr = S_OK;
 
     session->presentation.flags &= ~SESSION_FLAG_FINALIZE_SINKS;
-    session->state = SESSION_STATE_FINALIZING_SINKS;
+    session_set_state(session, SESSION_STATE_FINALIZING_SINKS);
 
     LIST_FOR_EACH_ENTRY(sink, &session->presentation.sinks, struct media_sink, entry)
     {
@@ -1436,7 +1479,7 @@ static void session_close(struct media_session *session)
         case SESSION_STATE_PAUSED:
             session->presentation.flags |= SESSION_FLAG_FINALIZE_SINKS;
             if (SUCCEEDED(hr = IMFPresentationClock_Stop(session->clock)))
-                session->state = SESSION_STATE_STOPPING_SINKS;
+                session_set_state(session, SESSION_STATE_STOPPING_SINKS);
             break;
         default:
             hr = MF_E_INVALIDREQUEST;
@@ -2574,7 +2617,7 @@ static HRESULT WINAPI mfsession_Shutdown(IMFMediaSession *iface)
     EnterCriticalSection(&session->cs);
     if (SUCCEEDED(hr = session_is_shut_down(session)))
     {
-        session->state = SESSION_STATE_SHUT_DOWN;
+        session_set_state(session, SESSION_STATE_SHUT_DOWN);
         IMFMediaEventQueue_Shutdown(session->event_queue);
         if (session->quality_manager)
             IMFQualityManager_Shutdown(session->quality_manager);
@@ -3405,7 +3448,7 @@ static void session_set_source_object_state(struct media_session *session, IUnkn
                         }
                     }
                 }
-                session->state = SESSION_STATE_PREROLLING_SINKS;
+                session_set_state(session, SESSION_STATE_PREROLLING_SINKS);
             }
             else
             {
@@ -3422,7 +3465,7 @@ static void session_set_source_object_state(struct media_session *session, IUnkn
                     if (session_is_output_nodes_state(session, OBJ_STATE_STARTED))
                         session_set_started(session);
                     else
-                        session->state = SESSION_STATE_STARTING_SINKS;
+                        session_set_state(session, SESSION_STATE_PREROLLING_SINKS);
                 }
                 else
                 {
@@ -3451,7 +3494,7 @@ static void session_set_source_object_state(struct media_session *session, IUnkn
                     return;
                 }
             }
-            session->state = SESSION_STATE_STARTING_SOURCES;
+            session_set_state(session, SESSION_STATE_STARTING_SINKS);
             break;
         case SESSION_STATE_PAUSING_SOURCES:
             if (!session_is_source_nodes_state(session, OBJ_STATE_PAUSED))
@@ -3498,7 +3541,7 @@ static void session_set_sink_stream_state(struct media_session *session, IMFStre
                 break;
 
             if (SUCCEEDED(session_start_clock(session)))
-                session->state = SESSION_STATE_STARTING_SINKS;
+                session_set_state(session, SESSION_STATE_STARTING_SINKS);
             break;
         case SESSION_STATE_STARTING_SINKS:
             if (!session_is_output_nodes_state(session, OBJ_STATE_STARTED))
-- 
2.50.1

